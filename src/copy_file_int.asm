; AH = 0x16
; SI = Source file.
; DI = Destination file.
COPY_FILE_INT:
	MOV CX, DI

	MOV BX, DOS_SEGMENT
	MOV ES, BX 
	MOV BX, DATA_BUFFER
	MOV DI, .FILENAME
	CALL CONVERT_LE_AND_TRAVERSE
	JC .ERROR

	MOV DX, DS
	MOV DI, ES
	MOV DS, DI 

	CMP AX, WORD[WORKING_DIRECTORY_FIRST_SECTOR]
	JNE .OTHER_DIRECTORY

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[WORKING_DIRECTORY]

.OTHER_DIRECTORY:
	MOV SI, .FILENAME
	CALL FIND_ENTRY
	JC .NOT_FOUND

	MOV AL, BYTE[ES:BX + 11]
	TEST AL, 0x10
	JNZ .IS_DIRECTORY
	MOV BYTE[.ATTRIBUTES], AL 

	MOV AX, WORD[ES:BX + 26]
	MOV WORD[.FIRST_CLUSTER], AX
	MOV AX, WORD[ES:BX + 28]
	MOV WORD[.SIZE_LOWER], AX
	MOV AX, WORD[ES:BX + 30]
	MOV WORD[.SIZE_UPPER], AX

	MOV DS, DX
	MOV SI, CX
	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER

	CALL CHECK_IF_LAST_IS_SEPERATOR
	JE .KEEP_SOURCE_FILENAME

	MOV DI, .FILENAME
	CALL CONVERT_LE_AND_TRAVERSE
	JNC .CONTINUE
	JMP .ERROR

.KEEP_SOURCE_FILENAME:
	CALL TRAVERSE_PATH
	JC .ERROR

.CONTINUE:
	MOV DI, ES
	MOV DS, DI

	CMP AX, WORD[WORKING_DIRECTORY_FIRST_SECTOR]
	JNE .OK

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[WORKING_DIRECTORY]

.OK:
	MOV WORD[.DIRECTORY_FIRST_CLUSTER], AX
	MOV WORD[.DIRECTORY_SEGMENT], ES
	MOV WORD[.DIRECTORY_OFFSET], BX

	PUSH BX
	MOV SI, .FILENAME
	CALL FIND_ENTRY
	POP BX
	JNC .ENTRY_ALREADY_EXISTS

	MOV AX, WORD[.FIRST_CLUSTER]
	MOV DH, BYTE[.ATTRIBUTES]
	CALL CREATE_ENTRY

	MOV AX, WORD[.SIZE_LOWER]
	MOV WORD[ES:DI + 28], AX
	MOV AX, WORD[.SIZE_UPPER]
	MOV WORD[ES:DI + 30], AX

	CALL GET_FREE_CLUSTER
	JC .OUT_OF_SPACE

	MOV WORD[ES:DI + 26], AX

	PUSH AX
	MOV AX, WORD[.DIRECTORY_FIRST_CLUSTER]
	CALL GET_DIRECTORY_SIZE
	CALL STORE_DIRECTORY
	POP AX
	JC .RELOAD_FS

	CMP WORD[.FIRST_CLUSTER], 0
	JZ .EXIT

	MOV CX, AX
	MOV SI, WORD[.FIRST_CLUSTER]

	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER + 113 * 32

.COPY_LOOP:
	MOV AX, CX
	MOV DX, 0xFFF
	CALL WRITE_CLUSTER ; Write an end of file marker just in case.

	MOV AX, SI
	CALL READ_DATA
	JC .RELOAD_FS

	MOV AX, CX
	CALL WRITE_DATA
	JC .RELOAD_FS

	MOV AX, SI
	CALL GET_NEXT_CLUSTER
	CMP AX, 0xFF0
	JAE .DONE_COPYING

	MOV SI, AX

	CALL GET_FREE_CLUSTER
	JC .OUT_OF_SPACE

	MOV DX, AX
	MOV AX, CX
	CALL WRITE_CLUSTER

	MOV CX, DX

	JMP .COPY_LOOP

.DONE_COPYING:
	XOR BX, BX
	MOV ES, BX
	MOV BX, FILESYSTEM
	MOV DL, BYTE[DRIVE_NUMBER]
	CALL STORE_FAT
	JC .RELOAD_FS

.EXIT:
	XOR AH, AH
	INT 0x13
        JMP RET_CODE_INT

.OUT_OF_SPACE:
	MOV DH, 0x49

.RELOAD_FS: ; TODO: ko bo narejen mehanizem za detekcijo zamenjave disket, naj ob neuspesni obnovitvi postane disk neveljaven.
	MOV AX, WORD[.DIRECTORY_FIRST_CLUSTER]
	MOV ES, WORD[.DIRECTORY_SEGMENT]
	MOV BX, WORD[.DIRECTORY_OFFSET]
	MOV BYTE[ES:DI], 0xE5
	PUSH DX
	CALL STORE_DIRECTORY
	POP DX

	XOR BX, BX
	MOV ES, BX
	MOV BX, FILESYSTEM
	MOV DL, BYTE[DRIVE_NUMBER] 
	PUSH DX
	CALL LOAD_FAT
	POP DX

	MOV AX, WORD[.DIRECTORY_FIRST_CLUSTER]
	CMP AX, WORD[WORKING_DIRECTORY_FIRST_SECTOR]
	JNE .OUT

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[WORKING_DIRECTORY]
	PUSH DX
	CALL LOAD_DIRECTORY
	POP DX

.OUT:
	JMP .ERROR

.IS_DIRECTORY:
	MOV DH, 0x45
	JMP .ERROR

.ENTRY_ALREADY_EXISTS:
	MOV DH, 0x44
	JMP .ERROR

.NOT_FOUND:
	MOV DH, 0x43

.ERROR:
	MOV AX, DOS_SEGMENT
	MOV DS, AX

	MOV BYTE[INT_RET_CODE], DH
	JMP RET_CODE_INT

.FILENAME: TIMES 11 DB 0
.ATTRIBUTES: DB 0
.FIRST_CLUSTER: DW 0
.SIZE_LOWER: DW 0
.SIZE_UPPER: DW 0
.DIRECTORY_SEGMENT: DW 0
.DIRECTORY_OFFSET: DW 0
.DIRECTORY_FIRST_CLUSTER: DW 0
