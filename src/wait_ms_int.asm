; AH = 0x22
; CX = Number of milliseconds to wait.
WAIT_MS_INT:
	MOV AX, DOS_SEGMENT
	MOV DS, AX

	MOV WORD[DELAY_COUNTER], CX

	CLI
	; XOR AL, AL
	; OUT 0x43, AL

	; IN AL, 0x40
	; MOV BYTE[.COUNT_LOW], AL
	; IN AL, 0x40
	; MOV BYTE[.COUNT_HIGH], AL

	; MOV AL, 0b00110100
	; OUT 0x43, AL

	; MOV AL, 1193 & 0xFF
	; OUT 0x40, AL
	; MOV AL, 1193 >> 8
	; OUT 0x40, AL

	XOR BX, BX
	MOV ES, BX
	MOV BX, 0x08 * 4

	MOV DX, WORD[ES:BX]
	MOV WORD[INT0_ORIGINAL_OFFSET], DX
	MOV DX, WORD[ES:BX + 2]
	MOV WORD[INT0_ORIGINAL_SEGMENT], DX

	MOV WORD[ES:BX], WAIT_MS_ISR
	MOV WORD[ES:BX + 2], DS
	STI

.WAIT:
	CMP WORD[DELAY_COUNTER], 0
	JNZ .WAIT

	CLI
	; MOV AL, 0b00110100
	; OUT 0x43, AL

	; MOV AL, BYTE[.COUNT_LOW]
	; OUT 0x40, AL
	; MOV AL, BYTE[.COUNT_HIGH]
	; OUT 0x40, AL

	MOV DX, WORD[INT0_ORIGINAL_OFFSET]
	MOV WORD[ES:BX], DX
	MOV DX, WORD[INT0_ORIGINAL_SEGMENT]
	MOV WORD[ES:BX + 2], DX
	STI

	JMP RET_INT

.COUNT_LOW: DB 0
.COUNT_HIGH: DB 0

WAIT_MS_ISR:
	PUSHF
	MOV AX, DOS_SEGMENT
	PUSH AX
	MOV AX, RETURN_OFFSET
	PUSH AX
	DB 0xEA
INT0_ORIGINAL_OFFSET: DW 0
INT0_ORIGINAL_SEGMENT: DW 0

RETURN_OFFSET:
	PUSH AX

	MOV AX, DOS_SEGMENT
	MOV DS, AX

	MOV AX, WORD[DELAY_COUNTER]

	TEST AX, AX
	JZ .ZERO

	DEC AX

.ZERO:
	MOV WORD[DELAY_COUNTER], AX

	MOV AL, 0x20
	OUT 0x20, AL
	POP AX
	IRET

DELAY_COUNTER: DW 0
