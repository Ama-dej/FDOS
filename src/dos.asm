[BITS 16]
[ORG 0x0000]
%INCLUDE "src/locations.h"

	MOV WORD[CURRENT_DIRECTORY], DX
	MOV DX, DI
	MOV WORD[DATA_AREA_BEGIN], DX

	XOR AX, AX
	MOV SS, AX
	MOV SP, 0x7E00
	MOV BP, SP

	MOV BX, 0x0000
	MOV ES, BX
	MOV BX, 0x80 * 4

	MOV WORD[ES:BX], DOS_INT
	MOV WORD[ES:BX + 2], DS

	MOV DS, AX

	MOV SI, 0x7C00
	MOV AX, DOS_SEGMENT
	MOV ES, AX
	MOV DI, BPB 
	MOV CX, 62
	CALL MEMCPY

	MOV DS, AX

	XOR DX, DX
	MOVZX AX, BYTE[SECTORS_PER_CLUSTER]
	MUL WORD[BYTES_PER_SECTOR]
	MOV WORD[BYTES_PER_CLUSTER], AX

	CALL LOG2
	MOV BYTE[LOG2_CLUSTER_SIZE], CL

	MOV AH, 0x01
	MOV SI, DOS_STARTUP_MSG
	MOV CX, DOS_STARTUP_MSG_END - DOS_STARTUP_MSG
	INT 0x80

DOS_START:
	MOV AL, 0x00
	MOV DI, DOS_SEGMENT
	MOV ES, DI
	MOV DI, COMMAND
	MOV CX, 128
	CALL MEMSET

	MOV AH, 0x0E
	MOV AL, '>'
	INT 0x10

.AT_LEAST_ONE_CHARACTER:
	MOV AH, 0x02
	MOV SI, COMMAND
	MOV CX, 79
	INT 0x80

	CMP BYTE[COMMAND], 0x00
	JZ .AT_LEAST_ONE_CHARACTER

	MOV AH, 0x0E
	MOV AL, 0x0A
	INT 0x10
	MOV AL, 0x0D
	INT 0x10

	MOV DI, DOS_SEGMENT
	MOV ES, DI
	MOV DI, COMMAND_PARSED

	CLD

PARSE_COMMAND:
	CMP BYTE[SI], ' '
	JNE .STORE

	INC DI

.SPACE_LOOP:
	CMP BYTE[SI], ' '
	JNE .STORE
	INC SI
	DEC CX
	JZ .OUT
	JMP .SPACE_LOOP

.STORE:
	MOV AL, BYTE[SI]
	CALL TO_UPPER
	STOSB
	INC SI
	LOOP PARSE_COMMAND

.OUT:
	MOV SI, COMMAND_LIST
	MOV DI, COMMAND_PARSED
	XOR BX, BX

FIND_COMMAND:
	CALL STRCMP
	JZ COMMAND_FOUND

	CALL STRLEN
	INC CX

	ADD SI, CX
	INC BX

	CMP BYTE[SI], 0xFF
	JNE FIND_COMMAND

	CMP BYTE[COMMAND_PARSED], '\'
	JE LOAD_BINARY

	MOV AH, 0x01
	MOV SI, COMMAND_NOT_FOUND_MSG
	MOV CX, COMMAND_NOT_FOUND_MSG_END - COMMAND_NOT_FOUND_MSG
	INT 0x80

	JMP DOS_START

LOAD_BINARY:
	MOV BX, FILE_TARGET_SEGMENT
	MOV ES, BX 
	XOR BX, BX
	MOV BX, 0x0000

	MOV AH, 0x04
	MOV SI, COMMAND_PARSED + 1
	MOV CX, 0xFFFF
	MOV DX, 0
	MOV DI, 0
	INT 0x80

	CMP AL, 0x01
	JE NOT_FOUND

	CMP AL, 0x02
	JE READ_ERROR

	MOV BX, FILE_TARGET_SEGMENT
	MOV DS, BX

	JMP FILE_TARGET_SEGMENT:0x0000

NOT_FOUND:
	MOV AH, 0x01
	MOV SI, FILE_NOT_FOUND_MSG
	MOV CX, FILE_NOT_FOUND_MSG_END - FILE_NOT_FOUND_MSG
	INT 0x80

	JMP DOS_START

READ_ERROR:
	MOV AH, 0x01
	MOV SI, READ_ERROR_MSG
	MOV CX, READ_ERROR_MSG_END - READ_ERROR_MSG
	INT 0x80

	JMP DOS_START

COMMAND_FOUND:
	SHL BX, 1
	ADD BX, COMMAND_ADDRESS_LIST

	MOV AX, WORD[BX]

	JMP AX

; COMMANDS
; --------

; Clears the screen.
; More specificaly sets the screen to 80x25 CGA mode (which is basically clearing the screen).
CLS:
	MOV AX, 0x0003
	INT 0x10
	INT 0x80

; Prints out all files and their sizes (in KiB) in a directory.
DIR:
	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[CURRENT_DIRECTORY]

.PRINT_NAME_LOOP:
	CMP BYTE[ES:BX], 0
	JZ .OUT

	CMP BYTE[ES:BX], 0xE5
	JNE .OK1

	ADD BX, 32
	JMP .PRINT_NAME_LOOP

.OK1:
	CALL NLCR

	CALL PRINT_FILENAME

	MOV AL, ' '
	CALL PUTCHAR

	CALL PRINT_FILE_SIZE

	ADD BX, 32
	MOV CX, 3

.PRINT_MORE:
	CMP BYTE[ES:BX], 0
	JZ .OUT

	CMP BYTE[ES:BX], 0xE5
	JNE .OK2

	ADD BX, 32
	JMP .PRINT_MORE

.OK2:
	MOV AH, 0x0E
	MOV AL, ' '
	INT 0x10
	INT 0x10

	CALL PRINT_FILENAME

	INT 0x10

	CALL PRINT_FILE_SIZE

	ADD BX, 32
	LOOP .PRINT_MORE

	JMP .PRINT_NAME_LOOP

.OUT:
	CALL NLCR

	XOR AH, AH
	INT 0x80

; Does a system reboot.
REBOOT:
	XOR AH, AH
	INT 0x13
	JMP 0xFFFF:0x0000

TEMPNAME: DB "SNAKE   BIN"

TEST:
	MOV AX, 1

.LOOP:
	CALL LOG2

	MOVZX DX, CL
	PUSH AX
	MOV AH, 0x03
	INT 0x80
	POP AX

	CALL NLCR

	SHL AX, 1
	JNZ .LOOP

.OUT:
	XOR AH, AH
	INT 0x80

; PROCEDURES
; ----------

; BL <- Value to print.
PUTH8:
	PUSH AX
	PUSH CX
	MOV AH, 0x0E
	MOV CX, 2

.LOOP:
	ROL BL, 4
	MOV AL, BL
	AND AL, 0x0F

	CMP AL, 10
	SBB AL, 0x69
	DAS

	INT 0x10

	DEC CX
	JNZ .LOOP

	POP CX
	POP AX
	RET

; AL <- Character.
;
; AL -> Character converted to uppercase.
TO_UPPER:
	CMP AL, 'a'
	JL .OUT

	CMP AL, 'z'
	JG .OUT

	SUB AL, 32

.OUT:
	RET

UPDATE_FS:
	CALL STORE_FAT

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[CURRENT_DIRECTORY]

	XOR DX, DX

	MOVZX AX, BYTE[NUMBER_OF_FAT]
	MUL WORD[SECTORS_PER_FAT]
	ADD AX, WORD[RESERVED_SECTORS]

	MOV DX, WORD[ROOT_ENTRIES]
	ADD DX, 15
	SHR DX, 4

	MOV CL, DL
	MOV DL, BYTE[DRIVE_NUMBER]

	CALL WRITE_DISK

	RET

STORE_FAT:
	PUSHA
	PUSH ES

	MOV CX, WORD[SECTORS_PER_FAT]

	XOR BX, BX
	MOV ES, BX
	MOV BX, FILESYSTEM

	MOV AX, WORD[RESERVED_SECTORS]
	MOV DL, BYTE[DRIVE_NUMBER]
	MOV DH, BYTE[NUMBER_OF_FAT]

.STORE_LOOP:
	CALL WRITE_DISK

	ADD AX, CX

	DEC DH
	JNZ .STORE_LOOP

	POP ES
	POPA
	RET

; SI <- Filename to convert.
; ES:DI <- Pointer to where to store the string.
;
; CF -> Cleared if successful.
CONVERT_TO_8_3:
	PUSHA

	MOV AL, ' '
	MOV CX, 11
	CALL MEMSET
	
	MOV BX, DI

	CLC
	MOV CX, 8

.LOOP:
	LODSB

	CMP AL, '.'
	JE .DOT

	CMP AL, 0x00
	JE .OUT

	CMP CX, 0
	JNZ .STORE_BYTE

	STC
	JMP .OUT

.STORE_BYTE:
	STOSB
	DEC CX
	JMP .LOOP

.DOT:
	MOV DI, BX
	ADD DI, 8
	MOV CX, 3
	JMP .LOOP

.OUT:
	POPA
	RET

; ES:BX <- Pointer to file entry.
PRINT_FILE_SIZE:
	PUSH AX
	PUSH CX
	PUSH DX
	PUSH SI

	CALL GET_FILE_SIZE

	MOV AH, 0x03
	INT 0x80

	MOV AL, 'K'
	CALL PUTCHAR

	POP SI
	POP DX
	POP CX
	POP AX
	RET

; ES:BX <- Pointer to file entry.
;
; DX -> File size in KiB.
GET_FILE_SIZE:
	PUSH AX

	MOV DX, WORD[ES:BX + 28]
	ADD DX, 1023

	MOV AX, WORD[ES:BX + 30]
	ADC AX, 0
	SHL AX, 6

	SHR DX, 10
	ADD DX, AX

	POP AX
	RET

; Prints a new line and a carrige return.
NLCR:
	PUSH AX

	MOV AH, 0x0E
	MOV AL, 0x0A
	INT 0x10
	MOV AL, 0x0D
	INT 0x10

	POP AX
	RET

; AL <- Character to print out.
PUTCHAR:
	PUSH AX

	MOV AH, 0x0E
	INT 0x10

	POP AX
	RET

; SI <- Pointer to first string.
; DI <- Pointer to second string.
;
; ZF <- Set if strings are equal.
STRCMP:
	PUSH AX
	PUSH SI
	PUSH DI

.CMP_LOOP:
	LODSB
	CMP BYTE[DI], AL
	JNE .OUT

	INC DI

	CMP AL, 0x00
	JNZ .CMP_LOOP

.OUT:
	POP DI
	POP SI
	POP AX
	RET

; SI <- Pointer to string.
;
; CX -> String length.
STRLEN:
	PUSH SI
	XOR CX, CX

.LOOP:
	LODSB
	TEST AL, AL
	JZ .OUT
	INC CX
	JMP .LOOP

.OUT:
	POP SI
	RET

; ES:BX <- Pointer to file entry.
PRINT_FILENAME:
	PUSH AX
	PUSH BX
	PUSH CX

	MOV AH, 0x0E
	MOV CX, 11

.PRINT_LOOP:
	MOV AL, BYTE[ES:BX]
	INT 0x10

	CMP CX, 4
	JNE .NOT_DOT

	MOV AL, '.'
	INT 0x10

.NOT_DOT:
	INC BX
	LOOP .PRINT_LOOP

.OUT:
	POP CX
	POP BX
	POP AX
	RET

; ES:BX <- Start of directory.
; SI <- File name to find.
;
; CF -> Set if not found.
; BX -> Location of entry.
FIND_ENTRY:
	CLC

.LOOP:
	CMP BYTE[ES:BX], 0
	JZ .ERROR

	CALL FILENAMECMP
	JE .OUT

	ADD BX, 32
	JMP .LOOP

.ERROR:
	STC

.OUT:
	RET	

; ES:BX <- File name in directory entry.
; SI <- File name to compare to.
;
; ZF -> Set if equal.
FILENAMECMP:
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH SI

	MOV CX, 11

.LOOP:
	LODSB

	CMP AL, BYTE[ES:BX]
	JNE .OUT

	INC BX
	LOOP .LOOP

	XOR AX, AX

.OUT:
	POP SI
	POP CX
	POP BX
	POP AX
	RET

; AL <- Value to set to.
; ES:DI <- Pointer to buffer.
; CX <- Number of bytes to set.
MEMSET:
	PUSH CX
	PUSH DI

.LOOP:
	TEST CX, CX
	JZ .OUT
	MOV BYTE[ES:DI], AL
	INC DI 
	LOOP .LOOP

.OUT:
	POP DI
	POP CX
	RET

; SI <- Source buffer.
; ES:DI <- Destination buffer.
; CX <- Number of bytes to copy.
MEMCPY:
	PUSH AX
	PUSH CX
	PUSH SI
	PUSH DI

	TEST CX, CX
	JZ .OUT

.LOOP:
	LODSB
	STOSB
	LOOP .LOOP

.OUT:
	POP DI
	POP SI
	POP CX
	POP AX
	RET

; AX <- Current cluster.
; ES:BX <- Source buffer.
WRITE_DATA:
	PUSH AX
	PUSH CX
	PUSH DX

	SUB AX, 2
	MOVZX CX, BYTE[SECTORS_PER_CLUSTER]
	MUL CX 

	ADD AX, WORD[DATA_AREA_BEGIN]
	MOV CL, BYTE[SECTORS_PER_CLUSTER]
	MOV DL, BYTE[DRIVE_NUMBER]
	CALL WRITE_DISK

	POP DX
	POP CX
	POP AX
	RET

; AX <- Current cluster.
; ES:BX <- Destination buffer.
READ_DATA:
	PUSH AX
	PUSH CX
	PUSH DX

	SUB AX, 2
	MOVZX CX, BYTE[SECTORS_PER_CLUSTER]
	MUL CX 

	ADD AX, WORD[DATA_AREA_BEGIN]
	MOV CL, BYTE[SECTORS_PER_CLUSTER]
	MOV DL, BYTE[DRIVE_NUMBER]
	CALL READ_DISK

	POP DX
	POP CX
	POP AX
	RET

; AX <- Cluster to write to.
; DX <- Value to write.
WRITE_CLUSTER:
	PUSH ES
	PUSH BX
	PUSH DX

	MOV BX, FILESYSTEM >> 4
	MOV ES, BX
	MOV BX, AX

	SHR BX, 1
	ADD BX, AX

	TEST AX, 1
	JZ .EVEN_CLUSTER

	SHL DX, 4
	AND WORD[ES:BX], 0x000F
	OR WORD[ES:BX], DX
	JMP .ODD_CLUSTER

.EVEN_CLUSTER:
	AND WORD[ES:BX], 0xF000
	OR WORD[ES:BX], DX

.ODD_CLUSTER:
	POP DX
	POP BX
	POP ES
	RET

; AX -> Free cluster location.
GET_FREE_CLUSTER:
	PUSH ES
	PUSH BX

	XOR AX, AX

	MOV BX, FILESYSTEM >> 4
	MOV ES, BX

.SEARCH:
	MOV BX, AX
	SHR BX, 1
	ADD BX, AX

	PUSH AX
	MOV AX, WORD[ES:BX]
	TEST AX, 1
	JZ .EVEN_CLUSTER	

	AND AX, 0x0FFF
	POP AX
	JZ .OUT
	INC AX
	JMP .SEARCH

.EVEN_CLUSTER:
	SHR AX, 4
	POP AX
	JZ .OUT
	INC AX
	JMP .SEARCH

.OUT:
	POP BX
	POP ES
	RET

; AX <- Current cluster.
;
; AX -> Next cluster.
GET_NEXT_CLUSTER:
	PUSH ES
	PUSH BX

	MOV BX, FILESYSTEM >> 4
	MOV ES, BX
	MOV BX, AX
	SHR BX, 1
	ADD BX, AX

	TEST AX, 1
	MOV AX, WORD[ES:BX]
	JZ .EVEN_CLUSTER

	SHR AX, 4
	JMP .ODD_CLUSTER

.EVEN_CLUSTER:
	AND AX, 0x0FFF
	
.ODD_CLUSTER:
	POP BX
	POP ES
	RET

; AX <- LBA value.
; CL <- Number of sectors to write.
; DL <- Drive number.
; ES:BX <- Pointer to buffer.
WRITE_DISK:
	PUSHA
	PUSH ES

	MOVZX DI, CL

.WRITE_LOOP:
	CALL LBA_TO_CHS
	CALL WRITE_CHS
	JC .RETURN

	MOV SI, ES
	ADD SI, 32
	MOV ES, SI
	
	INC AX
	DEC DI
	JNZ .WRITE_LOOP

.RETURN:
	POP ES
	POPA
	RET

; ES:BX <- Pointer to buffer to be written.
; CX[0:5] <- Sector number.
; CX[6:15] <- Track/Cylinder.
; DH <- Head number.
; DL <- Drive number.
WRITE_CHS:
	PUSH DI
	MOV DI, 3

.READ_LOOP:
	STC
	PUSH AX
	MOV AH, 0x03
	MOV AL, 1
	INT 0x13
	POP AX
	JNC .OUT

	DEC DI
	JNZ .READ_LOOP
	STC

.OUT:
	POP DI
	RET

; AX <- LBA value.
; CL <- Number of sectors to read.
; DL <- Drive number.
; ES:BX <- Pointer to buffer.
READ_DISK:
	PUSHA
	PUSH ES

	MOVZX DI, CL

.READ_LOOP:
	CALL LBA_TO_CHS
	CALL READ_CHS
	JC .RETURN

	MOV SI, ES
	ADD SI, 32
	MOV ES, SI
	
	INC AX
	DEC DI
	JNZ .READ_LOOP

.RETURN:
	POP ES
	POPA
	RET

; ES:BX <- Pointer to target buffer.
; CX[0:5] <- Sector number.
; CX[6:15] <- Track/Cylinder.
; DH <- Head number.
; DL <- Drive number.
READ_CHS:
	PUSH DI
	MOV DI, 3

.READ_LOOP:
	STC
	PUSH AX
	MOV AH, 0x02
	MOV AL, 1
	INT 0x13
	POP AX
	JNC .OUT

	DEC DI
	JNZ .READ_LOOP
	STC

.OUT:
	POP DI
	RET

; AX <- LBA value.
;
; CX[0:5] -> Sector number.
; CX[6:15] -> Track/Cylinder.
; DH -> Head number.
LBA_TO_CHS:
	PUSH AX
	PUSH DX

	XOR DX, DX
	DIV WORD[SECTORS_PER_TRACK]
	INC DX
	MOV CL, DL ; Get the sector number.

	XOR DX, DX
	DIV WORD[HEAD_COUNT]
	SHL DX, 8 ; Get the head number.

	MOV CH, AL
	SHL AH, 6
	OR CL, AH ; Get the number of tracks/cylinders.

	MOV AL, DH
	POP DX
	MOV DH, AL
	POP AX
	RET

RESET_DISK:
	PUSH AX
	PUSH DX

	MOV AH, 0x00
	MOV DL, BYTE[DRIVE_NUMBER]
	INT 0x13

	POP DX
	POP AX
	RET

; AX <- Value.
;
; CL -> Result.
LOG2:
	PUSH AX

	XOR CL, CL

.LOOP:
	SHR AX, 1

	TEST AX, AX
	JZ .OUT
	INC CL
	JMP .LOOP

.OUT:
	POP AX
	RET

; FDOS INTERRUPT (INT 0x80)
; -------------------------

DOS_INT:
	PUSHA

	PUSH BX
	PUSH DS

	MOV BX, DOS_SEGMENT
	MOV DS, BX

	MOV BYTE[INT_RET_CODE], 0x00

	MOVZX BX, AH
	SHL BX, 1
	ADD BX, INT_JUMP_TABLE
	MOV AX, WORD[BX]

	POP DS
	POP BX

	JMP AX 

; AH = 0x00
; Returns from the program to 16-DOS.
EXIT_INT:
	POPA

	MOV AX, DOS_SEGMENT
	MOV DS, AX

	XOR AX, AX
	MOV SS, AX
	MOV SP, 0x7E00

	JMP DOS_SEGMENT:DOS_START

; AH = 0x01
; SI = Pointer to string.
; CX = Number of bytes to print.
PRINT_INT:
	CLD
	MOV AH, 0x0E

.PRINT_LOOP:
	LODSB
	INT 0x10
	LOOP .PRINT_LOOP

	JMP RET_INT

; AH = 0x02
; SI = Pointer to buffer.
; CX = Maximum number of bytes to get from the user.
; Scan terminates when the enter key is pressed.
SCAN_INT:
	MOV DX, SI	
	INC CX

.SCAN_LOOP:
	MOV AH, 0x00
	INT 0x16

	CMP AL, 0x0D
	JE RET_INT

	CMP AL, 0x08
	JE .BACKSPACE_PRESSED

	TEST CX, CX
	JZ .SCAN_LOOP

	MOV AH, 0x0E
	INT 0x10

	MOV BYTE[SI], AL
	INC SI
	LOOP .SCAN_LOOP

.BACKSPACE_PRESSED:
	CMP SI, DX
	JE .SCAN_LOOP

	PUSHA
	MOV AH, 0x03
	MOV BH, 0
	INT 0x10

	CMP DL, 0
	JNZ .MOVE_NORMAL

	MOV DL, 80
	DEC DH

.MOVE_NORMAL:
	MOV AH, 0x02
	DEC DL
	INT 0x10

	MOV AH, 0x0A
	MOV AL, ' '
	MOV BL, 7
	MOV CX, 1
	INT 0x10
	POPA

	DEC SI
	MOV BYTE[SI], 0x00
	INC CX
	JMP .SCAN_LOOP

; AH = 0x03
; DX = Value to print.
PRINTI_INT:
	MOV AX, DX
	MOV BX, 10
	XOR CX, CX

.DIV_LOOP:
	XOR DX, DX
	DIV BX

	ADD DX, 48
	PUSH DX

	INC CX
	TEST AX, AX
	JNZ .DIV_LOOP

.PRINT_LOOP:
	POP AX
	MOV AH, 0x0E
	INT 0x10
	LOOP .PRINT_LOOP

	JMP RET_INT

INT_FILENAME_BUFFER: TIMES 11 DB ' '

; AH = 0x04
; ES:BX = Destination buffer.
; SI = Pointer to filename.
; CX = Number of bytes to read.
; DX/DI = Byte offset
; DX = Lower part of offset.
; DI = Higher part of offset.
READFILE_INT:
	PUSH DS
	PUSH ES
	PUSH BX
	PUSH DI

	MOV AX, DOS_SEGMENT
	MOV ES, AX
	MOV DI, INT_FILENAME_BUFFER
	CALL CONVERT_TO_8_3
	JC .LABEL_HACK ; Evil hack to save a few instructions.

	MOV DS, AX
	MOV SI, INT_FILENAME_BUFFER
	MOV DI, BX

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[CURRENT_DIRECTORY]
	CALL FIND_ENTRY

	MOV SI, DOS_SEGMENT
	MOV DS, SI

	MOV AX, WORD[ES:BX + 28]
	MOV WORD[FILE_SIZE_LOWER], AX
	MOV AX, WORD[ES:BX + 30]
	MOV WORD[FILE_SIZE_UPPER], AX

	MOV AX, WORD[ES:BX + 26]

.LABEL_HACK:
	POP DI
	POP BX
	POP ES
	JC .NOT_FOUND

	PUSH ES

	CMP DI, WORD[FILE_SIZE_UPPER]
        JA .READ_ERROR
	JB .SUBTRACT

        CMP DX, WORD[FILE_SIZE_LOWER]
        JA .READ_ERROR 

.SUBTRACT:
        SUB WORD[FILE_SIZE_UPPER], DI
        SUB WORD[FILE_SIZE_LOWER], DX
        SBB WORD[FILE_SIZE_UPPER], 0

	PUSH BX
	SHR BX, 4
	AND BX, 0xFFF0
	MOV SI, ES
	ADD SI, BX
	DEC SI
	MOV ES, SI
	POP BX
	AND BX, 0x00FF
	ADD BX, 16

	CALL RESET_DISK

.GET_TO_CLUSTER_OFFSET:
	CMP DI, 0
	JNZ .SKIP

	CMP DX, WORD[BYTES_PER_CLUSTER] 
	JB .READ_LOOP

.SKIP:
	SUB DX, WORD[BYTES_PER_CLUSTER]
	SBB DI, 0

	CALL GET_NEXT_CLUSTER
	JMP .GET_TO_CLUSTER_OFFSET	

.READ_LOOP:
	PUSH ES
	PUSH BX

	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER

	CALL READ_DATA
	POP BX
	POP ES
	JC .READ_ERROR

	CALL GET_NEXT_CLUSTER

	PUSH CX
	PUSH DI

	MOV DI, WORD[BYTES_PER_CLUSTER]

	CMP AX, 0xFF8
	JL .PROCEED

	CMP CX, WORD[FILE_SIZE_LOWER]
	JB .COPY_DATA

	MOV CX, WORD[FILE_SIZE_LOWER]
	JMP .COPY_DATA

.PROCEED:
	MOV CX, DI
	SUB CX, DX
	SUB WORD[FILE_SIZE_LOWER], CX
	SBB WORD[FILE_SIZE_UPPER], 0

.COPY_DATA:
	MOV SI, DATA_BUFFER
	ADD SI, DX
	MOV DI, BX
	CALL MEMCPY

	POP DI
	POP CX

	CMP CX, 0
	JZ .OUT

	ADD CX, DX
	SUB CX, WORD[BYTES_PER_CLUSTER]
	XOR DX, DX

	MOV DI, WORD[BYTES_PER_CLUSTER]
	SHR DI, 4

	PUSH DX
	SHR DX, 4

	MOV SI, ES
	ADD SI, DI
	SUB SI, DX
	MOV ES, SI
	POP DX

	AND DX, 0x000F
	SUB BX, DX

	CMP AX, 0xFF8
	JL .READ_LOOP

.OUT:
	POP ES
	POP DS
	JMP RET_CODE_INT

.NOT_FOUND:
	MOV BYTE[INT_RET_CODE], 0x01
	POP DS
	JMP RET_CODE_INT

.READ_ERROR:
	MOV BYTE[INT_RET_CODE], 0x02
	POP ES
	POP DS
	JMP RET_CODE_INT

FILE_SIZE_LOWER: DW 0
FILE_SIZE_UPPER: DW 0

; TODO: 
; - Vrž napako če zmanka prostora na disku.

; AH = 0x05
; ES:BX = Buffer to write.
; SI = Pointer to file entry.
; CX = Number of bytes to write.
; DX/DI = Byte offset
; DX = Lower part of offset.
; DI = Higher part of offset.
WRITEFILE_INT:
	PUSH DS
	PUSH ES
	PUSH BX
	PUSH DI

	MOV AX, DOS_SEGMENT
	MOV ES, AX
	MOV DI, INT_FILENAME_BUFFER
	CALL CONVERT_TO_8_3
	JC .LABEL_HACK ; Evil hack to save a few instructions.

	MOV DS, AX
	MOV SI, INT_FILENAME_BUFFER
	MOV DI, BX

	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[CURRENT_DIRECTORY]
	CALL FIND_ENTRY

	MOV SI, DOS_SEGMENT
	MOV DS, SI

	MOV AX, WORD[ES:BX + 28]
	MOV WORD[FILE_SIZE_LOWER], AX
	MOV AX, WORD[ES:BX + 30]
	MOV WORD[FILE_SIZE_UPPER], AX

	MOV AX, WORD[ES:BX + 26]
	MOV WORD[INT_TEMP], BX

.LABEL_HACK:
	POP DI
	POP BX
	POP ES
	JC .NOT_FOUND
	PUSH ES

	PUSH BX
	SHR BX, 4
	AND BX, 0xFFF0
	MOV SI, ES
	ADD SI, BX
	DEC SI
	MOV ES, SI
	POP BX
	AND BX, 0x00FF
	ADD BX, 16

	; PUSHA
	; MOV AH, 0x03
	; MOV DX, CX
	; INT 0x80
	; CALL NLCR
	; POPA

	CMP DI, WORD[FILE_SIZE_UPPER]
        JA .WRITE_ERROR
	JB .CONTINUE

        CMP DX, WORD[FILE_SIZE_LOWER]
        JA .WRITE_ERROR 

.CONTINUE:
	PUSH ES
	PUSH DX
	PUSH DI

	XOR SI, SI
	MOV ES, SI
	MOV SI, WORD[INT_TEMP]

	ADD DX, CX
	ADC DI, 0

	CMP DI, WORD[ES:SI + 30]
	JB .POP
	JA .STORE

	CMP DX, WORD[ES:SI + 28]
	JB .POP

.STORE:
	MOV WORD[ES:SI + 30], DI
	MOV WORD[ES:SI + 28], DX

.POP:
	POP DI
	POP DX
	POP ES

	CALL RESET_DISK

	CMP AX, 0
	JNZ .GET_TO_STARTING_CLUSTER

	PUSH ES
	PUSH DX
	PUSH SI

	XOR SI, SI
	MOV ES, SI
	MOV SI, WORD[INT_TEMP]

	CALL GET_FREE_CLUSTER
	MOV WORD[ES:SI + 26], AX

	MOV DX, 0xFFF
	CALL WRITE_CLUSTER

	POP SI
	POP DX
	POP ES

.GET_TO_STARTING_CLUSTER:
	CMP DI, 0
	JNZ .SKIP

.SKIP:
	CMP DX, WORD[BYTES_PER_SECTOR]
	JB .WRITE_LOOP

	SUB DX, WORD[BYTES_PER_SECTOR]
	SBB DI, 0

	MOV WORD[INT_WRITE_LAST], AX
	CALL GET_NEXT_CLUSTER
	JMP .GET_TO_STARTING_CLUSTER

.WRITE_LOOP:
	CMP AX, 0xFF8
	JL .OK

	PUSH DX
	CALL GET_FREE_CLUSTER

	MOV DX, 0xFFF
	CALL WRITE_CLUSTER

	MOV DX, AX
	MOV AX, WORD[INT_WRITE_LAST]
	CALL WRITE_CLUSTER

	MOV AX, DX

	POP DX

.OK:
	PUSH CX
	PUSH ES
	PUSH BX
	PUSH BX
	PUSH ES

	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER

	PUSH CX
	ADD CX, DX
	CMP CX, WORD[BYTES_PER_CLUSTER]
	POP CX
	JB .READ_DATA

	MOV CX, WORD[BYTES_PER_CLUSTER]

	CMP DX, 0
	JZ .COPY_DATA

	SUB CX, DX

.READ_DATA:
	; PUSH AX
	; MOV AL, '*'
	; CALL PUTCHAR
	; POP AX

	CALL READ_DATA
	JNC .COPY_DATA

	POP ES
	POP BX
	POP BX
	POP ES
	POP CX
	JMP .WRITE_ERROR

.COPY_DATA:
	POP DS
	POP SI
	MOV DI, DATA_BUFFER
	ADD DI, DX
	CALL MEMCPY

	MOV SI, DOS_SEGMENT
	MOV DS, SI

	; PUSHA
	; MOV AH, 0x03
	; MOV DX, CX
	; INT 0x80
	; CALL NLCR
	; POPA

	CALL WRITE_DATA
	JC .WRITE_ERROR

	POP BX
	POP ES
	POP CX

	ADD CX, DX

	; CMP CX, WORD[BYTES_PER_CLUSTER] ; <- Najdi boljši način za to šalabajzarijo!!!!!1, ne
	CMP CX, WORD[BYTES_PER_CLUSTER]
	JBE .OUT

	SUB CX, WORD[BYTES_PER_CLUSTER]

	MOV DI, WORD[BYTES_PER_CLUSTER]
	SHR DI, 4

	PUSH DX
	SHR DX, 4

	MOV SI, ES
	ADD SI, DI
	SUB SI, DX
	MOV ES, SI 
	POP DX

	AND DX, 0x000F
	SUB BX, DX
	XOR DX, DX

	MOV WORD[INT_WRITE_LAST], AX
	CALL GET_NEXT_CLUSTER

	JMP .WRITE_LOOP

.OUT:
	CALL UPDATE_FS
	POP ES
	POP DS
	JMP RET_CODE_INT

.NOT_FOUND:
	CALL UPDATE_FS
	MOV BYTE[INT_RET_CODE], 0x01
	POP DS
	JMP RET_CODE_INT

.WRITE_ERROR:
	PUSH AX
	MOV AL, 'a'
	CALL PUTCHAR
	POP AX

	CALL UPDATE_FS
	MOV BYTE[INT_RET_CODE], 0x02
	POP ES
	POP DS
	JMP RET_CODE_INT

INT_WRITE_LAST: DW 0

; AH = 0x06
; SI = Pointer to 78 byte buffer.
COMMAND_PARAMETERS_INT:
	JMP RET_INT

RET_CODE_INT:
	POPA
	PUSH BX
	PUSH DS 
	MOV BX, DOS_SEGMENT
	MOV DS, BX
	MOV AL, BYTE[INT_RET_CODE]
	POP DS
	POP BX
	IRET

RET_INT:
	POPA
	IRET

INT_RET_CODE: DB 0
INT_TEMP: DW 0
INT_TEMP_JUNIOR: DW 0

INT_JUMP_TABLE:
EXIT_INT_ADDRESS: DW EXIT_INT
PRINT_INT_ADDRESS: DW PRINT_INT
SCAN_INT_ADDRESS: DW SCAN_INT
PRINTI_INT_ADDRESS: DW PRINTI_INT
READFILE_INT_ADDRESS: DW READFILE_INT
WRITEFILE_INT_ADDRESS: DW WRITEFILE_INT ; <- Zamenjaj z WRITEFILE_INT, ko bo prekinitev varna.
COMMAND_PARAMETERS_INT_ADDRESS: DW COMMAND_PARAMETERS_INT
RETURN_FROM_INT_ADDRESS: TIMES 256 - ((RETURN_FROM_INT_ADDRESS - INT_JUMP_TABLE) / 2) DW RET_INT
INT_JUMP_TABLE_END:

COMMAND_LIST:
CLS_COMMAND: DB "CLS", 0x00
DIR_COMMAND: DB "DIR", 0x00
REBOOT_COMMAND: DB "REBOOT", 0x00
TEST_COMMAND: DB "TEST", 0x00
COMMAND_LIST_END: DB 0xFF

COMMAND_ADDRESS_LIST:
CLS_ADDRESS: DW CLS
DIR_ADDRESS: DW DIR
REBOOT_ADDRESS: DW REBOOT
TEST_ADDRESS: DW TEST
COMMAND_ADDRESS_LIST_END:

DOS_STARTUP_MSG: DB "This is FDOS version 0.", 0x0A, 0x0D
DOS_STARTUP_MSG_END:

COMMAND_NOT_FOUND_MSG: DB "Command not found.", 0x0A, 0x0D
COMMAND_NOT_FOUND_MSG_END:

FILE_NOT_FOUND_MSG: DB "File not found.", 0x0A, 0x0D
FILE_NOT_FOUND_MSG_END:

READ_ERROR_MSG: DB "Failed to read file.", 0x0A, 0x0D
READ_ERROR_MSG_END:

COMMAND: TIMES 79 DB 0
COMMAND_PARSED: TIMES 79 DB 0

CONVERTED_8_3: TIMES 11 DB ' '

; CURRENT_DIRECTORY_FIRST_SECTOR: DW 0
CURRENT_DIRECTORY: DW 0
DATA_AREA_BEGIN: DW 0
BYTES_PER_CLUSTER: DW 0
LOG2_CLUSTER_SIZE: DB 0

BPB:
SHORT_JUMP:
JMP SHORT BOOT_CODE
NOP
OEM: DB "FDOS    "
BYTES_PER_SECTOR: DW 0
SECTORS_PER_CLUSTER: DB 0
RESERVED_SECTORS: DW 0
NUMBER_OF_FAT: DB 0
ROOT_ENTRIES: DW 0
SECTOR_COUNT: DW 0
MEDIA_DESCRIPTOR: DB 0
SECTORS_PER_FAT: DW 0
SECTORS_PER_TRACK: DW 0
HEAD_COUNT: DW 0
HIDDEN_SECTORS: DD 0
LARGE_SECTOR_COUNT: DD 0

EBR:
DRIVE_NUMBER: DB 0
RESERVED: DB 0
SIGNATURE: DB 0x0
VOLUME_ID: DD 0xFFDD0055
VOLUME_LABEL: DB "FDOS       "
IDENTIFIER_STRING: DB "FAT12   "
BOOT_CODE:

DATA_BUFFER:
