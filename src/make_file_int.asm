; AH = 0x14
; SI = Path to file.
; DH = File attributes.
MAKE_FILE_INT:
	MOV CL, DH

	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER ; Make room for new empty directory (irrelevant for files).
	MOV DI, .CONVERTED_FILENAME
	CALL CONVERT_LE_AND_TRAVERSE
	JC .ERROR

	MOV DX, ES
	MOV DS, DX

	MOV WORD[.DIRECTORY], AX

	CMP AX, WORD[WORKING_DIRECTORY_FIRST_SECTOR]
	JE .WORKING_DIRECTORY

	JMP .CREATE_ENTRY

.WORKING_DIRECTORY:
	XOR BX, BX
	MOV ES, BX
	MOV BX, WORD[WORKING_DIRECTORY]

.CREATE_ENTRY:
	TEST CL, 0x10
	JNZ .IS_DIRECTORY

	XOR AX, AX
	MOV DH, CL
	MOV SI, .CONVERTED_FILENAME
	CALL CREATE_ENTRY
	JC .ERROR

	JMP .SAVE_CHANGES

.IS_DIRECTORY:
	CALL GET_FREE_CLUSTER
	JC .NO_FREE_SPACE

	MOV WORD[.NEW_DIRECTORY], AX

	MOV DH, CL
	MOV SI, .CONVERTED_FILENAME
	CALL CREATE_ENTRY
	JC .ERROR

	PUSH DI
	PUSH ES
	PUSH BX
	MOV BX, DOS_SEGMENT
	MOV ES, BX
	MOV BX, DATA_BUFFER + 113 * 32

	MOV BYTE[ES:BX], 0xE5
	MOV BYTE[ES:BX + 32], 0
	MOV BYTE[ES:BX + 64], 0

	MOV AX, WORD[.DIRECTORY]
	MOV DH, 0x10
	MOV SI, .BACK_ENTRY
	CALL CREATE_ENTRY

	MOV AX, WORD[.NEW_DIRECTORY]
	MOV DH, 0x10
	MOV SI, .CURRENT_ENTRY
	CALL CREATE_ENTRY

	MOV CX, 3
	CALL STORE_DIRECTORY
	POP BX
	POP ES
	POP DI
	JC .WRITE_ERROR

	MOV DX, 0xFFF
	CALL WRITE_CLUSTER

	PUSH ES
	PUSH BX
	XOR BX, BX
	MOV ES, BX
	MOV BX, FILESYSTEM
	MOV DL, BYTE[DRIVE_NUMBER] ; Update this part when the STORE_FAT procedure is updated
	CALL STORE_FAT
	POP BX
	POP ES
	JC .WRITE_ERROR

	XOR AH, AH
	INT 0x13

.SAVE_CHANGES:
	MOV AX, WORD[.DIRECTORY]
	CALL GET_DIRECTORY_SIZE
	INC CX
	CALL STORE_DIRECTORY
	JMP RET_CODE_INT	

.NO_FREE_SPACE:
	MOV DH, 0x49
	JMP .ERROR

.WRITE_ERROR:
	MOV BYTE[ES:DI], 0xE5

.ERROR:
	MOV BYTE[INT_RET_CODE], DH
	JMP RET_CODE_INT
	
.CONVERTED_FILENAME: TIMES 11 DW 0
.DIRECTORY: DW 0
.NEW_DIRECTORY: DW 0
.BACK_ENTRY: DB "..         "
.CURRENT_ENTRY: DB ".          "
